const API_BASE = '/api';

export async function fetchStats() {
  const res = await fetch(API_BASE + '/stats');
  return res.json();
}

export async function fetchActiveNodes() {
  const res = await fetch(API_BASE + '/nodes/active');
  return res.json();
}

export async function fetchNodeInfo(identifier) {
  const res = await fetch(API_BASE + '/node/' + identifier);
  return res.json();
}

export async function fetchMiningStatus(nodeId) {
  const res = await fetch(API_BASE + '/mining/' + nodeId);
  return res.json();
}

export async function fetchClaimHistory(wallet) {
  const res = await fetch(API_BASE + '/claim/' + wallet + '/history');
  return res.json();
}

export async function fetchTokenData(wallet) {
  const res = await fetch(API_BASE + '/tokens/' + wallet);
  return res.json();
}

export async function fetchMiningDebug(wallet) {
  const res = await fetch(API_BASE + '/mining-debug/' + wallet);
  return res.json();
}

export async function fetchTokenOverview() {
  const res = await fetch(API_BASE + '/token-overview');
  return res.json();
}

export async function fetchEthPrice() {
  try {
    const res = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
    const data = await res.json();
    return data.ethereum.usd;
  } catch {
    return null;
  }
}

export function formatDateDMY(dateStr) {
  if (!dateStr) return '--';
  const d = new Date(dateStr);
  if (isNaN(d.getTime())) return '--';
  const day = d.getDate().toString().padStart(2, '0');
  const month = (d.getMonth() + 1).toString().padStart(2, '0');
  const year = d.getFullYear();
  return day + '/' + month + '/' + year;
}

export function formatDateTimeDMY(dateStr) {
  if (!dateStr) return '--';
  const d = new Date(dateStr);
  if (isNaN(d.getTime())) return '--';
  const day = d.getDate().toString().padStart(2, '0');
  const month = (d.getMonth() + 1).toString().padStart(2, '0');
  const year = d.getFullYear();
  let hours = d.getHours();
  const mins = d.getMinutes().toString().padStart(2, '0');
  const ampm = hours >= 12 ? 'PM' : 'AM';
  hours = hours % 12 || 12;
  return day + '/' + month + '/' + year + ', ' + hours + ':' + mins + ' ' + ampm;
}

export function formatTimeOnly(dateStr) {
  if (!dateStr) return '--';
  const d = new Date(dateStr);
  if (isNaN(d.getTime())) return '--';
  let hours = d.getHours();
  const mins = d.getMinutes().toString().padStart(2, '0');
  const ampm = hours >= 12 ? 'PM' : 'AM';
  hours = hours % 12 || 12;
  return hours + ':' + mins + ' ' + ampm;
}

// Helper function to load image as base64
async function loadImageAsBase64(url) {
  try {
    const response = await fetch(url);
    const blob = await response.blob();
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onloadend = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(blob);
    });
  } catch (error) {
    console.error('Failed to load image:', error);
    return null;
  }
}

export async function exportToPDF({ nodeInfo, miningStatus, claimHistory, tokenData, miningDebug, chartData, dateRange }) {
  const { jsPDF } = await import('jspdf');
  
  const pdf = new jsPDF('p', 'mm', 'a4');
  const pageWidth = 210;
  const pageHeight = 297;
  const margin = 12;
  const contentWidth = pageWidth - margin * 2;
  
  const node = nodeInfo?.node || {};
  const metrics = node.nodeMetrics || {};
  const mining = miningStatus || {};
  const contractDetails = mining.contractDetails || {};
  const miningData = contractDetails.miningInfo || {};
  const debug = miningDebug || {};
  const debugContract = debug.contract || {};
  const debugMining = debugContract.miningInfo || {};
  const debugWallet = debug.wallet || {};
  const tokens = tokenData || {};
  const syncHistory = node.syncHistory || [];
  
  const colors = {
    bg: [15, 23, 42],
    card: [30, 41, 59],
    orange: [249, 115, 22],
    green: [34, 197, 94],
    text: [255, 255, 255],
    textMuted: [148, 163, 184],
    textDark: [100, 116, 139]
  };

  // Store generation timestamp for footer
  const generatedTimestamp = formatDateTimeDMY(new Date());

  // Background
  pdf.setFillColor(...colors.bg);
  pdf.rect(0, 0, pageWidth, pageHeight, 'F');

  let y = margin;

  // Load and add logo
  try {
    const logoBase64 = await loadImageAsBase64('/logo.png');
    if (logoBase64) {
      // Add logo image centered at top (16mm x 16mm)
      const logoSize = 16;
      pdf.addImage(logoBase64, 'PNG', (pageWidth - logoSize) / 2, y, logoSize, logoSize);
      y += logoSize + 4;
    } else {
      // Fallback: draw orange circle with N
      pdf.setFillColor(...colors.orange);
      pdf.circle(pageWidth / 2, y + 8, 8, 'F');
      pdf.setTextColor(255, 255, 255);
      pdf.setFontSize(7);
      pdf.text('N', pageWidth / 2, y + 10, { align: 'center' });
      y += 20;
    }
  } catch {
    // Fallback: draw orange circle with N
    pdf.setFillColor(...colors.orange);
    pdf.circle(pageWidth / 2, y + 8, 8, 'F');
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(7);
    pdf.text('N', pageWidth / 2, y + 10, { align: 'center' });
    y += 20;
  }

  // Title
  pdf.setFontSize(18);
  pdf.setTextColor(...colors.text);
  pdf.text('Netrum AI', pageWidth / 2, y, { align: 'center' });
  
  y += 6;
  pdf.setFontSize(10);
  pdf.setTextColor(...colors.textMuted);
  pdf.text('Node Dashboard Report', pageWidth / 2, y, { align: 'center' });

  // Generated timestamp in top right
  pdf.setFontSize(7);
  pdf.setTextColor(...colors.textDark);
  pdf.text('Generated: ' + generatedTimestamp, pageWidth - margin, margin + 5, { align: 'right' });

  // Orange divider bar
  y += 8;
  pdf.setFillColor(...colors.orange);
  pdf.rect(margin, y, contentWidth, 1.5, 'F');
  y += 8;

  // Helper functions
  const drawCard = (x, yPos, w, h, title) => {
    pdf.setFillColor(...colors.card);
    pdf.roundedRect(x, yPos, w, h, 2, 2, 'F');
    pdf.setFillColor(...colors.orange);
    pdf.rect(x, yPos, 1.5, h, 'F');
    if (title) {
      pdf.setFontSize(9);
      pdf.setTextColor(...colors.orange);
      pdf.text(title, x + 6, yPos + 7);
    }
    return yPos + 12;
  };

  const addRow = (x, yPos, label, value, valueColor = colors.text) => {
    pdf.setFontSize(7);
    pdf.setTextColor(...colors.textMuted);
    pdf.text(label + ':', x, yPos);
    pdf.setTextColor(...valueColor);
    pdf.text(String(value || '--'), x + 28, yPos);
    return yPos + 5;
  };

  const cardWidth = (contentWidth - 4) / 2;
  const cardHeight = 42;

  // Row 1: Node Information + Performance Statistics
  let leftY = drawCard(margin, y, cardWidth, cardHeight, 'Node Information');
  leftY = addRow(margin + 6, leftY, 'Node ID', node.nodeId || '--');
  leftY = addRow(margin + 6, leftY, 'Wallet', node.wallet ? node.wallet.slice(0, 10) + '...' + node.wallet.slice(-6) : '--');
  leftY = addRow(margin + 6, leftY, 'Status', node.nodeStatus || '--', node.nodeStatus === 'Active' ? colors.green : colors.text);
  leftY = addRow(margin + 6, leftY, 'Sync Status', node.syncStatus || '--', node.syncStatus === 'Active' ? colors.green : colors.text);
  leftY = addRow(margin + 6, leftY, 'Registered', formatDateDMY(node.createdAt));
  addRow(margin + 6, leftY, 'Type', node.type || 'Lite');

  let rightY = drawCard(margin + cardWidth + 4, y, cardWidth, cardHeight, 'Performance Statistics');
  rightY = addRow(margin + cardWidth + 10, rightY, 'Total Tasks', node.taskCount?.toLocaleString() || '0');
  rightY = addRow(margin + cardWidth + 10, rightY, 'Sync Count', node.syncCount?.toLocaleString() || '0');
  rightY = addRow(margin + cardWidth + 10, rightY, 'Total Claims', tokens.totalClaims?.toString() || '0');
  rightY = addRow(margin + cardWidth + 10, rightY, 'TTS Power', node.ttsPowerStatus === 'available' ? 'Available' : 'Unavailable', node.ttsPowerStatus === 'available' ? colors.green : colors.textMuted);
  rightY = addRow(margin + cardWidth + 10, rightY, 'RAM TTS', (node.availableRamForTTS || 0) + ' GB');
  addRow(margin + cardWidth + 10, rightY, 'Permission', node.systemPermission ? 'Yes' : 'No', node.systemPermission ? colors.green : colors.textMuted);

  y += cardHeight + 4;

  // Row 2: System Metrics + Mining Status
  leftY = drawCard(margin, y, cardWidth, cardHeight, 'System Metrics');
  leftY = addRow(margin + 6, leftY, 'CPU Cores', metrics.cpu || '0');
  leftY = addRow(margin + 6, leftY, 'RAM', metrics.ram ? (metrics.ram / 1024).toFixed(1) + ' GB' : '--');
  leftY = addRow(margin + 6, leftY, 'Disk', metrics.disk ? metrics.disk + ' GB' : '--');
  leftY = addRow(margin + 6, leftY, 'Download', metrics.speed ? metrics.speed.toFixed(0) + ' Mbps' : '--');
  addRow(margin + 6, leftY, 'Upload', metrics.uploadSpeed ? metrics.uploadSpeed.toFixed(0) + ' Mbps' : '--');

  const walletBal = debugWallet.balanceEth || contractDetails.walletBalanceEth || 0;
  const minedTokens = debugMining.minedTokensFormatted || miningData.minedTokens || 0;
  const miningProgress = Math.min(100, (minedTokens / 3.7) * 100);

  rightY = drawCard(margin + cardWidth + 4, y, cardWidth, cardHeight, 'Mining Status');
  rightY = addRow(margin + cardWidth + 10, rightY, 'Status', miningProgress >= 100 ? 'Ready to Claim' : 'Mining', miningProgress >= 100 ? colors.green : colors.orange);
  rightY = addRow(margin + cardWidth + 10, rightY, 'Progress', miningProgress.toFixed(1) + '%', colors.orange);
  rightY = addRow(margin + cardWidth + 10, rightY, 'Session Mined', (typeof minedTokens === 'number' ? minedTokens.toFixed(4) : minedTokens) + ' NPT', colors.orange);
  rightY = addRow(margin + cardWidth + 10, rightY, 'Wallet Balance', walletBal.toFixed(6) + ' ETH');
  addRow(margin + cardWidth + 10, rightY, 'Cooldown', miningProgress >= 100 ? 'No' : 'Yes');

  y += cardHeight + 4;

  // Requirements Check
  const reqHeight = 22;
  drawCard(margin, y, contentWidth, reqHeight, 'Requirements Check');
  
  const reqs = [
    { label: 'CPU', req: '2', actual: metrics.cpu || 0, ok: metrics.cpu >= 2 },
    { label: 'RAM', req: '4GB', actual: metrics.ram ? (metrics.ram / 1024).toFixed(1) + 'GB' : '0', ok: metrics.ram >= 4096 },
    { label: 'Disk', req: '50GB', actual: metrics.disk ? metrics.disk + 'GB' : '0', ok: metrics.disk >= 50 },
    { label: 'Download', req: '5Mbps', actual: metrics.speed ? metrics.speed.toFixed(0) + 'Mbps' : '0', ok: metrics.speed >= 5 },
    { label: 'Upload', req: '5Mbps', actual: metrics.uploadSpeed ? metrics.uploadSpeed.toFixed(0) + 'Mbps' : '0', ok: metrics.uploadSpeed >= 5 }
  ];

  const reqColWidth = contentWidth / 5;
  reqs.forEach((r, i) => {
    const x = margin + i * reqColWidth + reqColWidth / 2;
    pdf.setFontSize(7);
    pdf.setTextColor(...colors.textMuted);
    pdf.text(r.label, x, y + 10, { align: 'center' });
    pdf.setFontSize(6);
    pdf.text('Req: ' + r.req, x, y + 14, { align: 'center' });
    pdf.text('Actual: ' + r.actual, x, y + 17, { align: 'center' });
    pdf.setTextColor(...(r.ok ? colors.green : [239, 68, 68]));
    pdf.text(r.ok ? 'PASS' : 'FAIL', x, y + 20, { align: 'center' });
  });

  y += reqHeight + 4;

  // Last Claim Details
  const claimHeight = 18;
  drawCard(margin, y, contentWidth, claimHeight, 'Last Claim Details');
  
  const lastClaim = claimHistory?.lastClaim || {};
  pdf.setFontSize(7);
  pdf.setTextColor(...colors.textMuted);
  pdf.text('Date: ' + formatDateTimeDMY(lastClaim.timestamp), margin + 6, y + 12);
  pdf.text('Node: ' + (lastClaim.nodeId || node.nodeId || '--'), margin + 6, y + 16);
  pdf.text('Tasks at Claim: ' + (lastClaim.taskCountAtTime?.toLocaleString() || node.taskCount?.toLocaleString() || '--'), margin + contentWidth / 2, y + 12);

  y += claimHeight + 4;

  // Sync History Summary
  const syncHeight = 16;
  drawCard(margin, y, contentWidth, syncHeight, 'Sync History Summary');
  
  const activeCount = syncHistory.filter(s => s.status === 'Active' || s.meetsRequirements).length;
  const uptimeRate = syncHistory.length > 0 ? ((activeCount / syncHistory.length) * 100).toFixed(1) : 0;
  
  pdf.setFontSize(7);
  pdf.setTextColor(...colors.textMuted);
  pdf.text('Recent Syncs: ' + (node.syncCount || 0), margin + 6, y + 12);
  pdf.text('Active Syncs: ' + activeCount, margin + contentWidth / 3, y + 12);
  pdf.setTextColor(...colors.green);
  pdf.text('Uptime Rate: ' + uptimeRate + '%', margin + contentWidth * 2 / 3, y + 12);

  y += syncHeight + 4;

  // Claims Chart with NPT values on bars
  if (chartData && chartData.labels && chartData.labels.length > 0) {
    const chartHeight = 50;
    const chartTitle = dateRange ? 'Claims History (' + dateRange + ')' : 'Claims History (Last 7 Days)';
    drawCard(margin, y, contentWidth, chartHeight, chartTitle);

    const labels = chartData.labels;
    const values = chartData.values;
    const maxVal = Math.max(...values, 0.1);

    const chartX = margin + 12;
    const chartY = y + 14;
    const chartW = contentWidth - 24;
    const chartH = 28;
    const barCount = labels.length;
    const barWidth = Math.min(15, (chartW / barCount) - 3);
    const gap = (chartW - (barWidth * barCount)) / (barCount + 1);

    values.forEach((v, i) => {
      const barH = maxVal > 0 ? (v / maxVal) * chartH : 0;
      const x = chartX + gap + i * (barWidth + gap);
      
      // Draw bar
      if (v > 0) {
        pdf.setFillColor(...colors.orange);
      } else {
        pdf.setFillColor(51, 65, 85);
      }
      pdf.rect(x, chartY + chartH - barH, barWidth, barH, 'F');
      
      // Draw NPT value on top of bar (white text)
      if (v > 0) {
        pdf.setFontSize(5);
        pdf.setTextColor(...colors.text);
        const valueText = v >= 10 ? v.toFixed(1) : v.toFixed(2);
        pdf.text(valueText, x + barWidth / 2, chartY + chartH - barH - 1, { align: 'center' });
      }
    });

    // X-axis labels
    pdf.setFontSize(5);
    pdf.setTextColor(...colors.textDark);
    labels.forEach((l, i) => {
      const x = chartX + gap + i * (barWidth + gap) + barWidth / 2;
      pdf.text(l, x, chartY + chartH + 4, { align: 'center' });
    });

    y += chartHeight + 4;
  }

  // Claims Summary
  if (tokens.totalClaims > 0) {
    const summaryHeight = 14;
    drawCard(margin, y, contentWidth, summaryHeight, 'Claims Summary');
    pdf.setFontSize(7);
    pdf.setTextColor(...colors.textMuted);
    pdf.text('Total Claims: ' + tokens.totalClaims, margin + 6, y + 11);
    pdf.setTextColor(...colors.orange);
    pdf.text('Total NPT: ' + tokens.totalNptClaimed?.toFixed(4) + ' NPT', margin + contentWidth / 3, y + 11);
    pdf.setTextColor(...colors.textMuted);
    pdf.text('Avg/Claim: ' + (tokens.totalNptClaimed / tokens.totalClaims).toFixed(4) + ' NPT', margin + contentWidth * 2 / 3, y + 11);
  }

  // Footer - Three part layout matching CORRECTED.pdf
  const footerHeight = 14;
  const footerY = pageHeight - footerHeight;
  
  pdf.setFillColor(...colors.card);
  pdf.rect(0, footerY, pageWidth, footerHeight, 'F');
  
  // Center: "Netrum AI Node Dashboard"
  pdf.setFontSize(8);
  pdf.setTextColor(...colors.text);
  pdf.text('Netrum AI Node Dashboard', pageWidth / 2, footerY + 6, { align: 'center' });
  
  // Left: "Built by D.i.PYâ„¢ | https://dipy.me"
  pdf.setFontSize(6);
  pdf.setTextColor(...colors.orange);
  pdf.text('Built by D.i.PY\u2122 | https://dipy.me', margin, footerY + 10);
  
  // Right: "Generated: timestamp"
  pdf.setTextColor(...colors.textMuted);
  pdf.text('Generated: ' + generatedTimestamp, pageWidth - margin, footerY + 10, { align: 'right' });

  pdf.save('netrum-node-report.pdf');
}

export default {
  fetchStats,
  fetchActiveNodes,
  fetchNodeInfo,
  fetchMiningStatus,
  fetchClaimHistory,
  fetchTokenData,
  fetchMiningDebug,
  fetchTokenOverview,
  fetchEthPrice,
  formatDateDMY,
  formatDateTimeDMY,
  formatTimeOnly,
  exportToPDF
};